To get cluster ip:

minikube ip

Pods are not meant to be seen from outside of the cluster, so they are only accessible from inside the cluster by default.

//////////////////////////////

SERVICES:

Since pods are ephemeral and come/go/live/die/restart, services are there to make sure they are pointed at any instance of a pod, no matter if its restarted or what.... With a service, we CAN connect to the k8s cluster and the service will find whatever pod to fill a request.

Pod Labels:
We can set up a series of key/value pairs (one or more pair). For example, we can give a pod a label whos key is 'app' and value is 'webapp'. You can give any labels you want, it's up to you. When we create a service, we give it a selector (key/value pair), such as app:webapp - and the service will look for any pods that have that key/value pair. So for a service with 

selector:
  app:webapp

The service will look for any pods that have the label
app:webapp

So next we'll create a service to point to our webapp pod!

For the service yaml, the metadata -> name, is absolutely critical - it needs to be a unique name. So you as an architect need to create a system for naming unique services.

If you make your service of type ClusterIP, you tell k8s that this service will only be accessible from within the cluster (good for internal microservices). Many microservices shouldn't be exposed to external traffic, so the type: ClusterIP would be good for those.
If you need your service to be accessible to outside traffic, use type: NodePort

The type NodePort exposes the port through the worker node. We can actually choose which NodePort we want to expose. we can add a key/value pair

ports:
  - name: http
    port: 80 # which pod port
    nodePort: 30080 # must be greater than 30000

Once the service and pod are applied, use minikube ip

it will give you the ip of the cluster, then since we have a NodePort 30080 on the service, we can use a browser to the cluster ip address:30080, and it will give us the app running in the pod!






